# 12월 13일

readLine() : String

```java
Scanner - next(), nextint(), nextDouble(), nextLine()
```

- 자기가 원하는 것만 읽고 원하는 것만 찾음

aaa bbb       ccc    ddd\n

next(), 분리문자가 아닌 문자를 제거하고 분리문자가 아닌 것을 읽음.

nextLine(), 

(개행문자)



aaa\n

bbb\n

ccc\n

ddd\n



## [상속 구문]

- 자바의 모든객체들은 상속이라는 객체지향언어의 특징을 지원한다.

- 자바에서 생성되는 모든 객체들은 기본적으로 java.lang.Object 이라는 객체를 상속하게 된다. (단지 Object이 부모냐 조상이냐의 차이.)

- 최상위에는 Object이라는 클래스가 있다.

- 상속을 하게 되면 클래스 헤더에 extends 라는 절을 사용하는 부모 클래스를 설정하는데 하나의 부모 클래스만 설정 가능하다. (C++의 op는 필요한 만큼 부모 클래스를 지정할 수 있는데 Java는 단일 상속. / C++의 단점 : 무거움. 혼란스러움.)

- 가장 적합하다고 판단되는 클래스를 상속해야 함.

- 조상으로부터 물려받은 메서드들은 필요에 따라 대체할 수 있다. (메서드 오버 라이딩이라 함.)

- 메서드 오버 로딩, 메서드 오버 라이딩

- 어떤 클래스든 객체를 생성하면 해당 클래스만 메모리 할당하는 것이 아니라 조상 클래스들도 메모리 할당한다. (필요한 멤버를 갖고 있는 조상을 상속해야 함. 메모리를 많이 쓸 우려.)

- 자손이 조상 걸 사용할 때 super, this를 사용할 수 있음. 

- 자손 클래스의 객체 생성 시에는 생성자 메서드가 호출되면 바로 조상 클래스의 생성자도 호출된다. 내부적으로는  arguments 없는 생성자가 호출되는데 다른 생성자를 호출하려는 경우 super라는 메서드를 사용한다.

- 객체를 참조하는 용도 : this(나의 멤버 호출), super(조상의 멤버 호출)

- 객체를 초기화하는 용도로 사용되는 생성자 메서드 호출에 : this(), super()

  this() - 같은 생성자 내에 다른 멤버가 대신 하게끔

  super() - 필요한 경우 꼭 구현해야 함

- this(), super()  : 생성자 안에서만 호출 가능 (둘 다 무조건 첫번째 행에 와야 함. 둘 중 하나만 써야.)

- this, super (Literal) : 객체 생성 시점에 초기화 된다.  static 메서드에서는 사용 불가. 

  ​                                    (non-static 메서드와 생성자 메서드에서만 사용 가능.)

- 



## [제어자 : modifier(*수정자/ **한정자, 제어자)]

### 수정자는 너무 직역. 오히려 한정자, 제어자라는 표현이 맞음.

- 접근 제어자 : public, protected, (default : 아무것도 안 준 거), private. 이 중에 하나만 지정 가능.
  - 누구는 접근할 수 있고 누구는 접근할 수 있는 지를 지정
- 활용 제어자 : **final, static, abstract**, transient, synchronized...
  - 역할을 한정시킴.
  - 서로 상반된 기능만 아니면 같이 지정 가능.

- 접근 제어자 먼저 오고 그 다음 활용 제어자.

- **제어자란 클래스, 메서드, 변수 앞에 설정되어 접근 가능 여부와 사용 방식을 제어하는 구문**

  ```java
  (제어자 : 생략 가능) class 클래스명 extends 부모클래스명 {
          (제어자) 멤버변수 선언 :;
          (제어자) 생성자 메서드 정의;
          (제어자) 메서드 정의;    
  }
  ```

  ```
  (public, final, abstract) class 클래스명 extends 부모클래스명 {
          (모든 접근 제어자, final, static) 멤버변수 선언 :;
          (모든 접근 제어자, 활용 제어자는 안 됨) 생성자 메서드 정의;
          (모든 접근 제어자, static, final, abstract) 메서드 정의;    
  }
  ```

- 클래스에는 접근 제어자를 두 가지만 설정 가능 : public, (default)

  - public이 설정된 클래스 : 누구나 
  - (default) : 동일 패키지 내의 클래스만 접근 가능
  - 클래스와 소스를 같이

- final : 변경할 수 없는, 마지막의 (제어자로서)

  abstract : 반드시 변경해야만 하는, 마지막이 아닌, 미완성의 (제어자로서)

  final 클래스 : 상속 불가능, 객체 생성은 가능

  abstract 클래스 :  객체 생성 불가능, 상속만 가능

- **public : 누구나 접근 가능, ** 

  protected : 동일 패키지거나 동일 자손이면 접근 가능

  (default) : 동일 패키지여야만 접근 가능 (자손이어도 안 됨)

  **private : 외부에서는 자손이든 객체를 생성한 클래스든 접근 불가능**

  ​                 **멤버가 정의된 클래스 내에서만 사용 가능**

- +: public

  #: protected

  (), ~: (default)

  -: private

- static, final을 함께 지정하여 상수를 만든다.

  ```java
  public class Math {
         public final static double PI = 3.14159
  }
  ```

  Math. PI

  Integer.MAX_VALUE

- 메서드에

  final : 자손에 의해 오버라이딩이 불가능한 메서드를 정의

  abstract : 자손에 의해 반드시 오버라이딩 해야 하는 메서드를 정의

  ​                  메서드의 헤더만 정의되고 바디가 없는 메서드

  

## [Java 컴파일러]

- Java의 실행파일은 바이너리파일. 바이트코드. -> JVM이 운영체제 알맞게 해석해서 실행.
- 
- 구문적인 오류가 있는지를 체크하여 있으면 알려줌.
- Java의 구문에 맞춰서 반드시 있어야 할 부분이 생략되어 있으면 채워넣어줌.